Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> scene
Rule 1     scene -> draws_instruction
Rule 2     draws_instruction -> draws_instruction shape
Rule 3     draws_instruction -> draws_instruction draw
Rule 4     draws_instruction -> shape
Rule 5     draws_instruction -> draw
Rule 6     draw -> DRAW ID INT COMMA INT
Rule 7     draw -> DRAW ID
Rule 8     draw -> DRAW NILL
Rule 9     shape -> SHAPE ID O_KEY pencil fill axiom
Rule 10    pencil -> PENCIL ID
Rule 11    pencil -> <empty>
Rule 12    fill -> FILL ID
Rule 13    fill -> <empty>
Rule 14    axiom -> AXIOM O_KEY instructions C_KEY rules
Rule 15    instructions -> instruction instructions
Rule 16    instructions -> instruction
Rule 17    instruction -> instruction_base
Rule 18    instruction -> CALL_SHAPE ID
Rule 19    instruction -> CALL_RULE ID
Rule 20    rules -> rule rules
Rule 21    rules -> depth
Rule 22    rule -> RULE ID O_KEY base instructions loop
Rule 23    base -> BASE TWO_POINT instruction_base
Rule 24    base -> BASE O_KEY instructions_base C_KEY
Rule 25    instructions_base -> instruction_base instructions_base
Rule 26    instructions_base -> instruction_base
Rule 27    instruction_base -> LEFT INT
Rule 28    instruction_base -> RIGHT INT
Rule 29    instruction_base -> LINE INT
Rule 30    instruction_base -> JUMP INT COMMA INT
Rule 31    instruction_base -> NILL
Rule 32    instruction_base -> PUSH INT COMMA INT
Rule 33    instruction_base -> POP
Rule 34    loop -> ITER INT C_KEY
Rule 35    loop -> C_KEY
Rule 36    depth -> DEPTH INT C_KEY
Rule 37    depth -> C_KEY

Terminals, with rules where they appear

AXIOM                : 14
BASE                 : 23 24
CALL_RULE            : 19
CALL_SHAPE           : 18
COMMA                : 6 30 32
C_KEY                : 14 24 34 35 36 37
DEPTH                : 36
DRAW                 : 6 7 8
FILL                 : 12
ID                   : 6 7 9 10 12 18 19 22
INT                  : 6 6 27 28 29 30 30 32 32 34 36
ITER                 : 34
JUMP                 : 30
LEFT                 : 27
LINE                 : 29
NILL                 : 8 31
O_KEY                : 9 14 22 24
PENCIL               : 10
POP                  : 33
PUSH                 : 32
RIGHT                : 28
RULE                 : 22
SHAPE                : 9
TWO_POINT            : 23
error                : 

Nonterminals, with rules where they appear

axiom                : 9
base                 : 22
depth                : 21
draw                 : 3 5
draws_instruction    : 1 2 3
fill                 : 9
instruction          : 15 16
instruction_base     : 17 23 25 26
instructions         : 14 15 22
instructions_base    : 24 25
loop                 : 22
pencil               : 9
rule                 : 20
rules                : 14 20
scene                : 0
shape                : 2 4

Parsing method: LALR

state 0

    (0) S' -> . scene
    (1) scene -> . draws_instruction
    (2) draws_instruction -> . draws_instruction shape
    (3) draws_instruction -> . draws_instruction draw
    (4) draws_instruction -> . shape
    (5) draws_instruction -> . draw
    (9) shape -> . SHAPE ID O_KEY pencil fill axiom
    (6) draw -> . DRAW ID INT COMMA INT
    (7) draw -> . DRAW ID
    (8) draw -> . DRAW NILL

    SHAPE           shift and go to state 5
    DRAW            shift and go to state 6

    scene                          shift and go to state 1
    draws_instruction              shift and go to state 2
    shape                          shift and go to state 3
    draw                           shift and go to state 4

state 1

    (0) S' -> scene .



state 2

    (1) scene -> draws_instruction .
    (2) draws_instruction -> draws_instruction . shape
    (3) draws_instruction -> draws_instruction . draw
    (9) shape -> . SHAPE ID O_KEY pencil fill axiom
    (6) draw -> . DRAW ID INT COMMA INT
    (7) draw -> . DRAW ID
    (8) draw -> . DRAW NILL

    $end            reduce using rule 1 (scene -> draws_instruction .)
    SHAPE           shift and go to state 5
    DRAW            shift and go to state 6

    shape                          shift and go to state 7
    draw                           shift and go to state 8

state 3

    (4) draws_instruction -> shape .

    SHAPE           reduce using rule 4 (draws_instruction -> shape .)
    DRAW            reduce using rule 4 (draws_instruction -> shape .)
    $end            reduce using rule 4 (draws_instruction -> shape .)


state 4

    (5) draws_instruction -> draw .

    SHAPE           reduce using rule 5 (draws_instruction -> draw .)
    DRAW            reduce using rule 5 (draws_instruction -> draw .)
    $end            reduce using rule 5 (draws_instruction -> draw .)


state 5

    (9) shape -> SHAPE . ID O_KEY pencil fill axiom

    ID              shift and go to state 9


state 6

    (6) draw -> DRAW . ID INT COMMA INT
    (7) draw -> DRAW . ID
    (8) draw -> DRAW . NILL

    ID              shift and go to state 10
    NILL            shift and go to state 11


state 7

    (2) draws_instruction -> draws_instruction shape .

    SHAPE           reduce using rule 2 (draws_instruction -> draws_instruction shape .)
    DRAW            reduce using rule 2 (draws_instruction -> draws_instruction shape .)
    $end            reduce using rule 2 (draws_instruction -> draws_instruction shape .)


state 8

    (3) draws_instruction -> draws_instruction draw .

    SHAPE           reduce using rule 3 (draws_instruction -> draws_instruction draw .)
    DRAW            reduce using rule 3 (draws_instruction -> draws_instruction draw .)
    $end            reduce using rule 3 (draws_instruction -> draws_instruction draw .)


state 9

    (9) shape -> SHAPE ID . O_KEY pencil fill axiom

    O_KEY           shift and go to state 12


state 10

    (6) draw -> DRAW ID . INT COMMA INT
    (7) draw -> DRAW ID .

    INT             shift and go to state 13
    SHAPE           reduce using rule 7 (draw -> DRAW ID .)
    DRAW            reduce using rule 7 (draw -> DRAW ID .)
    $end            reduce using rule 7 (draw -> DRAW ID .)


state 11

    (8) draw -> DRAW NILL .

    SHAPE           reduce using rule 8 (draw -> DRAW NILL .)
    DRAW            reduce using rule 8 (draw -> DRAW NILL .)
    $end            reduce using rule 8 (draw -> DRAW NILL .)


state 12

    (9) shape -> SHAPE ID O_KEY . pencil fill axiom
    (10) pencil -> . PENCIL ID
    (11) pencil -> .

    PENCIL          shift and go to state 15
    FILL            reduce using rule 11 (pencil -> .)
    AXIOM           reduce using rule 11 (pencil -> .)

    pencil                         shift and go to state 14

state 13

    (6) draw -> DRAW ID INT . COMMA INT

    COMMA           shift and go to state 16


state 14

    (9) shape -> SHAPE ID O_KEY pencil . fill axiom
    (12) fill -> . FILL ID
    (13) fill -> .

    FILL            shift and go to state 18
    AXIOM           reduce using rule 13 (fill -> .)

    fill                           shift and go to state 17

state 15

    (10) pencil -> PENCIL . ID

    ID              shift and go to state 19


state 16

    (6) draw -> DRAW ID INT COMMA . INT

    INT             shift and go to state 20


state 17

    (9) shape -> SHAPE ID O_KEY pencil fill . axiom
    (14) axiom -> . AXIOM O_KEY instructions C_KEY rules

    AXIOM           shift and go to state 22

    axiom                          shift and go to state 21

state 18

    (12) fill -> FILL . ID

    ID              shift and go to state 23


state 19

    (10) pencil -> PENCIL ID .

    FILL            reduce using rule 10 (pencil -> PENCIL ID .)
    AXIOM           reduce using rule 10 (pencil -> PENCIL ID .)


state 20

    (6) draw -> DRAW ID INT COMMA INT .

    SHAPE           reduce using rule 6 (draw -> DRAW ID INT COMMA INT .)
    DRAW            reduce using rule 6 (draw -> DRAW ID INT COMMA INT .)
    $end            reduce using rule 6 (draw -> DRAW ID INT COMMA INT .)


state 21

    (9) shape -> SHAPE ID O_KEY pencil fill axiom .

    SHAPE           reduce using rule 9 (shape -> SHAPE ID O_KEY pencil fill axiom .)
    DRAW            reduce using rule 9 (shape -> SHAPE ID O_KEY pencil fill axiom .)
    $end            reduce using rule 9 (shape -> SHAPE ID O_KEY pencil fill axiom .)


state 22

    (14) axiom -> AXIOM . O_KEY instructions C_KEY rules

    O_KEY           shift and go to state 24


state 23

    (12) fill -> FILL ID .

    AXIOM           reduce using rule 12 (fill -> FILL ID .)


state 24

    (14) axiom -> AXIOM O_KEY . instructions C_KEY rules
    (15) instructions -> . instruction instructions
    (16) instructions -> . instruction
    (17) instruction -> . instruction_base
    (18) instruction -> . CALL_SHAPE ID
    (19) instruction -> . CALL_RULE ID
    (27) instruction_base -> . LEFT INT
    (28) instruction_base -> . RIGHT INT
    (29) instruction_base -> . LINE INT
    (30) instruction_base -> . JUMP INT COMMA INT
    (31) instruction_base -> . NILL
    (32) instruction_base -> . PUSH INT COMMA INT
    (33) instruction_base -> . POP

    CALL_SHAPE      shift and go to state 28
    CALL_RULE       shift and go to state 29
    LEFT            shift and go to state 30
    RIGHT           shift and go to state 31
    LINE            shift and go to state 32
    JUMP            shift and go to state 33
    NILL            shift and go to state 34
    PUSH            shift and go to state 35
    POP             shift and go to state 36

    instructions                   shift and go to state 25
    instruction                    shift and go to state 26
    instruction_base               shift and go to state 27

state 25

    (14) axiom -> AXIOM O_KEY instructions . C_KEY rules

    C_KEY           shift and go to state 37


state 26

    (15) instructions -> instruction . instructions
    (16) instructions -> instruction .
    (15) instructions -> . instruction instructions
    (16) instructions -> . instruction
    (17) instruction -> . instruction_base
    (18) instruction -> . CALL_SHAPE ID
    (19) instruction -> . CALL_RULE ID
    (27) instruction_base -> . LEFT INT
    (28) instruction_base -> . RIGHT INT
    (29) instruction_base -> . LINE INT
    (30) instruction_base -> . JUMP INT COMMA INT
    (31) instruction_base -> . NILL
    (32) instruction_base -> . PUSH INT COMMA INT
    (33) instruction_base -> . POP

    C_KEY           reduce using rule 16 (instructions -> instruction .)
    ITER            reduce using rule 16 (instructions -> instruction .)
    CALL_SHAPE      shift and go to state 28
    CALL_RULE       shift and go to state 29
    LEFT            shift and go to state 30
    RIGHT           shift and go to state 31
    LINE            shift and go to state 32
    JUMP            shift and go to state 33
    NILL            shift and go to state 34
    PUSH            shift and go to state 35
    POP             shift and go to state 36

    instruction                    shift and go to state 26
    instructions                   shift and go to state 38
    instruction_base               shift and go to state 27

state 27

    (17) instruction -> instruction_base .

    CALL_SHAPE      reduce using rule 17 (instruction -> instruction_base .)
    CALL_RULE       reduce using rule 17 (instruction -> instruction_base .)
    LEFT            reduce using rule 17 (instruction -> instruction_base .)
    RIGHT           reduce using rule 17 (instruction -> instruction_base .)
    LINE            reduce using rule 17 (instruction -> instruction_base .)
    JUMP            reduce using rule 17 (instruction -> instruction_base .)
    NILL            reduce using rule 17 (instruction -> instruction_base .)
    PUSH            reduce using rule 17 (instruction -> instruction_base .)
    POP             reduce using rule 17 (instruction -> instruction_base .)
    C_KEY           reduce using rule 17 (instruction -> instruction_base .)
    ITER            reduce using rule 17 (instruction -> instruction_base .)


state 28

    (18) instruction -> CALL_SHAPE . ID

    ID              shift and go to state 39


state 29

    (19) instruction -> CALL_RULE . ID

    ID              shift and go to state 40


state 30

    (27) instruction_base -> LEFT . INT

    INT             shift and go to state 41


state 31

    (28) instruction_base -> RIGHT . INT

    INT             shift and go to state 42


state 32

    (29) instruction_base -> LINE . INT

    INT             shift and go to state 43


state 33

    (30) instruction_base -> JUMP . INT COMMA INT

    INT             shift and go to state 44


state 34

    (31) instruction_base -> NILL .

    CALL_SHAPE      reduce using rule 31 (instruction_base -> NILL .)
    CALL_RULE       reduce using rule 31 (instruction_base -> NILL .)
    LEFT            reduce using rule 31 (instruction_base -> NILL .)
    RIGHT           reduce using rule 31 (instruction_base -> NILL .)
    LINE            reduce using rule 31 (instruction_base -> NILL .)
    JUMP            reduce using rule 31 (instruction_base -> NILL .)
    NILL            reduce using rule 31 (instruction_base -> NILL .)
    PUSH            reduce using rule 31 (instruction_base -> NILL .)
    POP             reduce using rule 31 (instruction_base -> NILL .)
    C_KEY           reduce using rule 31 (instruction_base -> NILL .)
    ITER            reduce using rule 31 (instruction_base -> NILL .)


state 35

    (32) instruction_base -> PUSH . INT COMMA INT

    INT             shift and go to state 45


state 36

    (33) instruction_base -> POP .

    CALL_SHAPE      reduce using rule 33 (instruction_base -> POP .)
    CALL_RULE       reduce using rule 33 (instruction_base -> POP .)
    LEFT            reduce using rule 33 (instruction_base -> POP .)
    RIGHT           reduce using rule 33 (instruction_base -> POP .)
    LINE            reduce using rule 33 (instruction_base -> POP .)
    JUMP            reduce using rule 33 (instruction_base -> POP .)
    NILL            reduce using rule 33 (instruction_base -> POP .)
    PUSH            reduce using rule 33 (instruction_base -> POP .)
    POP             reduce using rule 33 (instruction_base -> POP .)
    C_KEY           reduce using rule 33 (instruction_base -> POP .)
    ITER            reduce using rule 33 (instruction_base -> POP .)


state 37

    (14) axiom -> AXIOM O_KEY instructions C_KEY . rules
    (20) rules -> . rule rules
    (21) rules -> . depth
    (22) rule -> . RULE ID O_KEY base instructions loop
    (36) depth -> . DEPTH INT C_KEY
    (37) depth -> . C_KEY

    RULE            shift and go to state 50
    DEPTH           shift and go to state 51
    C_KEY           shift and go to state 46

    rules                          shift and go to state 47
    rule                           shift and go to state 48
    depth                          shift and go to state 49

state 38

    (15) instructions -> instruction instructions .

    C_KEY           reduce using rule 15 (instructions -> instruction instructions .)
    ITER            reduce using rule 15 (instructions -> instruction instructions .)


state 39

    (18) instruction -> CALL_SHAPE ID .

    CALL_SHAPE      reduce using rule 18 (instruction -> CALL_SHAPE ID .)
    CALL_RULE       reduce using rule 18 (instruction -> CALL_SHAPE ID .)
    LEFT            reduce using rule 18 (instruction -> CALL_SHAPE ID .)
    RIGHT           reduce using rule 18 (instruction -> CALL_SHAPE ID .)
    LINE            reduce using rule 18 (instruction -> CALL_SHAPE ID .)
    JUMP            reduce using rule 18 (instruction -> CALL_SHAPE ID .)
    NILL            reduce using rule 18 (instruction -> CALL_SHAPE ID .)
    PUSH            reduce using rule 18 (instruction -> CALL_SHAPE ID .)
    POP             reduce using rule 18 (instruction -> CALL_SHAPE ID .)
    C_KEY           reduce using rule 18 (instruction -> CALL_SHAPE ID .)
    ITER            reduce using rule 18 (instruction -> CALL_SHAPE ID .)


state 40

    (19) instruction -> CALL_RULE ID .

    CALL_SHAPE      reduce using rule 19 (instruction -> CALL_RULE ID .)
    CALL_RULE       reduce using rule 19 (instruction -> CALL_RULE ID .)
    LEFT            reduce using rule 19 (instruction -> CALL_RULE ID .)
    RIGHT           reduce using rule 19 (instruction -> CALL_RULE ID .)
    LINE            reduce using rule 19 (instruction -> CALL_RULE ID .)
    JUMP            reduce using rule 19 (instruction -> CALL_RULE ID .)
    NILL            reduce using rule 19 (instruction -> CALL_RULE ID .)
    PUSH            reduce using rule 19 (instruction -> CALL_RULE ID .)
    POP             reduce using rule 19 (instruction -> CALL_RULE ID .)
    C_KEY           reduce using rule 19 (instruction -> CALL_RULE ID .)
    ITER            reduce using rule 19 (instruction -> CALL_RULE ID .)


state 41

    (27) instruction_base -> LEFT INT .

    CALL_SHAPE      reduce using rule 27 (instruction_base -> LEFT INT .)
    CALL_RULE       reduce using rule 27 (instruction_base -> LEFT INT .)
    LEFT            reduce using rule 27 (instruction_base -> LEFT INT .)
    RIGHT           reduce using rule 27 (instruction_base -> LEFT INT .)
    LINE            reduce using rule 27 (instruction_base -> LEFT INT .)
    JUMP            reduce using rule 27 (instruction_base -> LEFT INT .)
    NILL            reduce using rule 27 (instruction_base -> LEFT INT .)
    PUSH            reduce using rule 27 (instruction_base -> LEFT INT .)
    POP             reduce using rule 27 (instruction_base -> LEFT INT .)
    C_KEY           reduce using rule 27 (instruction_base -> LEFT INT .)
    ITER            reduce using rule 27 (instruction_base -> LEFT INT .)


state 42

    (28) instruction_base -> RIGHT INT .

    CALL_SHAPE      reduce using rule 28 (instruction_base -> RIGHT INT .)
    CALL_RULE       reduce using rule 28 (instruction_base -> RIGHT INT .)
    LEFT            reduce using rule 28 (instruction_base -> RIGHT INT .)
    RIGHT           reduce using rule 28 (instruction_base -> RIGHT INT .)
    LINE            reduce using rule 28 (instruction_base -> RIGHT INT .)
    JUMP            reduce using rule 28 (instruction_base -> RIGHT INT .)
    NILL            reduce using rule 28 (instruction_base -> RIGHT INT .)
    PUSH            reduce using rule 28 (instruction_base -> RIGHT INT .)
    POP             reduce using rule 28 (instruction_base -> RIGHT INT .)
    C_KEY           reduce using rule 28 (instruction_base -> RIGHT INT .)
    ITER            reduce using rule 28 (instruction_base -> RIGHT INT .)


state 43

    (29) instruction_base -> LINE INT .

    CALL_SHAPE      reduce using rule 29 (instruction_base -> LINE INT .)
    CALL_RULE       reduce using rule 29 (instruction_base -> LINE INT .)
    LEFT            reduce using rule 29 (instruction_base -> LINE INT .)
    RIGHT           reduce using rule 29 (instruction_base -> LINE INT .)
    LINE            reduce using rule 29 (instruction_base -> LINE INT .)
    JUMP            reduce using rule 29 (instruction_base -> LINE INT .)
    NILL            reduce using rule 29 (instruction_base -> LINE INT .)
    PUSH            reduce using rule 29 (instruction_base -> LINE INT .)
    POP             reduce using rule 29 (instruction_base -> LINE INT .)
    C_KEY           reduce using rule 29 (instruction_base -> LINE INT .)
    ITER            reduce using rule 29 (instruction_base -> LINE INT .)


state 44

    (30) instruction_base -> JUMP INT . COMMA INT

    COMMA           shift and go to state 52


state 45

    (32) instruction_base -> PUSH INT . COMMA INT

    COMMA           shift and go to state 53


state 46

    (37) depth -> C_KEY .

    SHAPE           reduce using rule 37 (depth -> C_KEY .)
    DRAW            reduce using rule 37 (depth -> C_KEY .)
    $end            reduce using rule 37 (depth -> C_KEY .)


state 47

    (14) axiom -> AXIOM O_KEY instructions C_KEY rules .

    SHAPE           reduce using rule 14 (axiom -> AXIOM O_KEY instructions C_KEY rules .)
    DRAW            reduce using rule 14 (axiom -> AXIOM O_KEY instructions C_KEY rules .)
    $end            reduce using rule 14 (axiom -> AXIOM O_KEY instructions C_KEY rules .)


state 48

    (20) rules -> rule . rules
    (20) rules -> . rule rules
    (21) rules -> . depth
    (22) rule -> . RULE ID O_KEY base instructions loop
    (36) depth -> . DEPTH INT C_KEY
    (37) depth -> . C_KEY

    RULE            shift and go to state 50
    DEPTH           shift and go to state 51
    C_KEY           shift and go to state 46

    rule                           shift and go to state 48
    rules                          shift and go to state 54
    depth                          shift and go to state 49

state 49

    (21) rules -> depth .

    SHAPE           reduce using rule 21 (rules -> depth .)
    DRAW            reduce using rule 21 (rules -> depth .)
    $end            reduce using rule 21 (rules -> depth .)


state 50

    (22) rule -> RULE . ID O_KEY base instructions loop

    ID              shift and go to state 55


state 51

    (36) depth -> DEPTH . INT C_KEY

    INT             shift and go to state 56


state 52

    (30) instruction_base -> JUMP INT COMMA . INT

    INT             shift and go to state 57


state 53

    (32) instruction_base -> PUSH INT COMMA . INT

    INT             shift and go to state 58


state 54

    (20) rules -> rule rules .

    SHAPE           reduce using rule 20 (rules -> rule rules .)
    DRAW            reduce using rule 20 (rules -> rule rules .)
    $end            reduce using rule 20 (rules -> rule rules .)


state 55

    (22) rule -> RULE ID . O_KEY base instructions loop

    O_KEY           shift and go to state 59


state 56

    (36) depth -> DEPTH INT . C_KEY

    C_KEY           shift and go to state 60


state 57

    (30) instruction_base -> JUMP INT COMMA INT .

    CALL_SHAPE      reduce using rule 30 (instruction_base -> JUMP INT COMMA INT .)
    CALL_RULE       reduce using rule 30 (instruction_base -> JUMP INT COMMA INT .)
    LEFT            reduce using rule 30 (instruction_base -> JUMP INT COMMA INT .)
    RIGHT           reduce using rule 30 (instruction_base -> JUMP INT COMMA INT .)
    LINE            reduce using rule 30 (instruction_base -> JUMP INT COMMA INT .)
    JUMP            reduce using rule 30 (instruction_base -> JUMP INT COMMA INT .)
    NILL            reduce using rule 30 (instruction_base -> JUMP INT COMMA INT .)
    PUSH            reduce using rule 30 (instruction_base -> JUMP INT COMMA INT .)
    POP             reduce using rule 30 (instruction_base -> JUMP INT COMMA INT .)
    C_KEY           reduce using rule 30 (instruction_base -> JUMP INT COMMA INT .)
    ITER            reduce using rule 30 (instruction_base -> JUMP INT COMMA INT .)


state 58

    (32) instruction_base -> PUSH INT COMMA INT .

    CALL_SHAPE      reduce using rule 32 (instruction_base -> PUSH INT COMMA INT .)
    CALL_RULE       reduce using rule 32 (instruction_base -> PUSH INT COMMA INT .)
    LEFT            reduce using rule 32 (instruction_base -> PUSH INT COMMA INT .)
    RIGHT           reduce using rule 32 (instruction_base -> PUSH INT COMMA INT .)
    LINE            reduce using rule 32 (instruction_base -> PUSH INT COMMA INT .)
    JUMP            reduce using rule 32 (instruction_base -> PUSH INT COMMA INT .)
    NILL            reduce using rule 32 (instruction_base -> PUSH INT COMMA INT .)
    PUSH            reduce using rule 32 (instruction_base -> PUSH INT COMMA INT .)
    POP             reduce using rule 32 (instruction_base -> PUSH INT COMMA INT .)
    C_KEY           reduce using rule 32 (instruction_base -> PUSH INT COMMA INT .)
    ITER            reduce using rule 32 (instruction_base -> PUSH INT COMMA INT .)


state 59

    (22) rule -> RULE ID O_KEY . base instructions loop
    (23) base -> . BASE TWO_POINT instruction_base
    (24) base -> . BASE O_KEY instructions_base C_KEY

    BASE            shift and go to state 62

    base                           shift and go to state 61

state 60

    (36) depth -> DEPTH INT C_KEY .

    SHAPE           reduce using rule 36 (depth -> DEPTH INT C_KEY .)
    DRAW            reduce using rule 36 (depth -> DEPTH INT C_KEY .)
    $end            reduce using rule 36 (depth -> DEPTH INT C_KEY .)


state 61

    (22) rule -> RULE ID O_KEY base . instructions loop
    (15) instructions -> . instruction instructions
    (16) instructions -> . instruction
    (17) instruction -> . instruction_base
    (18) instruction -> . CALL_SHAPE ID
    (19) instruction -> . CALL_RULE ID
    (27) instruction_base -> . LEFT INT
    (28) instruction_base -> . RIGHT INT
    (29) instruction_base -> . LINE INT
    (30) instruction_base -> . JUMP INT COMMA INT
    (31) instruction_base -> . NILL
    (32) instruction_base -> . PUSH INT COMMA INT
    (33) instruction_base -> . POP

    CALL_SHAPE      shift and go to state 28
    CALL_RULE       shift and go to state 29
    LEFT            shift and go to state 30
    RIGHT           shift and go to state 31
    LINE            shift and go to state 32
    JUMP            shift and go to state 33
    NILL            shift and go to state 34
    PUSH            shift and go to state 35
    POP             shift and go to state 36

    instructions                   shift and go to state 63
    instruction                    shift and go to state 26
    instruction_base               shift and go to state 27

state 62

    (23) base -> BASE . TWO_POINT instruction_base
    (24) base -> BASE . O_KEY instructions_base C_KEY

    TWO_POINT       shift and go to state 64
    O_KEY           shift and go to state 65


state 63

    (22) rule -> RULE ID O_KEY base instructions . loop
    (34) loop -> . ITER INT C_KEY
    (35) loop -> . C_KEY

    ITER            shift and go to state 67
    C_KEY           shift and go to state 68

    loop                           shift and go to state 66

state 64

    (23) base -> BASE TWO_POINT . instruction_base
    (27) instruction_base -> . LEFT INT
    (28) instruction_base -> . RIGHT INT
    (29) instruction_base -> . LINE INT
    (30) instruction_base -> . JUMP INT COMMA INT
    (31) instruction_base -> . NILL
    (32) instruction_base -> . PUSH INT COMMA INT
    (33) instruction_base -> . POP

    LEFT            shift and go to state 30
    RIGHT           shift and go to state 31
    LINE            shift and go to state 32
    JUMP            shift and go to state 33
    NILL            shift and go to state 34
    PUSH            shift and go to state 35
    POP             shift and go to state 36

    instruction_base               shift and go to state 69

state 65

    (24) base -> BASE O_KEY . instructions_base C_KEY
    (25) instructions_base -> . instruction_base instructions_base
    (26) instructions_base -> . instruction_base
    (27) instruction_base -> . LEFT INT
    (28) instruction_base -> . RIGHT INT
    (29) instruction_base -> . LINE INT
    (30) instruction_base -> . JUMP INT COMMA INT
    (31) instruction_base -> . NILL
    (32) instruction_base -> . PUSH INT COMMA INT
    (33) instruction_base -> . POP

    LEFT            shift and go to state 30
    RIGHT           shift and go to state 31
    LINE            shift and go to state 32
    JUMP            shift and go to state 33
    NILL            shift and go to state 34
    PUSH            shift and go to state 35
    POP             shift and go to state 36

    instructions_base              shift and go to state 70
    instruction_base               shift and go to state 71

state 66

    (22) rule -> RULE ID O_KEY base instructions loop .

    RULE            reduce using rule 22 (rule -> RULE ID O_KEY base instructions loop .)
    DEPTH           reduce using rule 22 (rule -> RULE ID O_KEY base instructions loop .)
    C_KEY           reduce using rule 22 (rule -> RULE ID O_KEY base instructions loop .)


state 67

    (34) loop -> ITER . INT C_KEY

    INT             shift and go to state 72


state 68

    (35) loop -> C_KEY .

    RULE            reduce using rule 35 (loop -> C_KEY .)
    DEPTH           reduce using rule 35 (loop -> C_KEY .)
    C_KEY           reduce using rule 35 (loop -> C_KEY .)


state 69

    (23) base -> BASE TWO_POINT instruction_base .

    CALL_SHAPE      reduce using rule 23 (base -> BASE TWO_POINT instruction_base .)
    CALL_RULE       reduce using rule 23 (base -> BASE TWO_POINT instruction_base .)
    LEFT            reduce using rule 23 (base -> BASE TWO_POINT instruction_base .)
    RIGHT           reduce using rule 23 (base -> BASE TWO_POINT instruction_base .)
    LINE            reduce using rule 23 (base -> BASE TWO_POINT instruction_base .)
    JUMP            reduce using rule 23 (base -> BASE TWO_POINT instruction_base .)
    NILL            reduce using rule 23 (base -> BASE TWO_POINT instruction_base .)
    PUSH            reduce using rule 23 (base -> BASE TWO_POINT instruction_base .)
    POP             reduce using rule 23 (base -> BASE TWO_POINT instruction_base .)


state 70

    (24) base -> BASE O_KEY instructions_base . C_KEY

    C_KEY           shift and go to state 73


state 71

    (25) instructions_base -> instruction_base . instructions_base
    (26) instructions_base -> instruction_base .
    (25) instructions_base -> . instruction_base instructions_base
    (26) instructions_base -> . instruction_base
    (27) instruction_base -> . LEFT INT
    (28) instruction_base -> . RIGHT INT
    (29) instruction_base -> . LINE INT
    (30) instruction_base -> . JUMP INT COMMA INT
    (31) instruction_base -> . NILL
    (32) instruction_base -> . PUSH INT COMMA INT
    (33) instruction_base -> . POP

    C_KEY           reduce using rule 26 (instructions_base -> instruction_base .)
    LEFT            shift and go to state 30
    RIGHT           shift and go to state 31
    LINE            shift and go to state 32
    JUMP            shift and go to state 33
    NILL            shift and go to state 34
    PUSH            shift and go to state 35
    POP             shift and go to state 36

    instruction_base               shift and go to state 71
    instructions_base              shift and go to state 74

state 72

    (34) loop -> ITER INT . C_KEY

    C_KEY           shift and go to state 75


state 73

    (24) base -> BASE O_KEY instructions_base C_KEY .

    CALL_SHAPE      reduce using rule 24 (base -> BASE O_KEY instructions_base C_KEY .)
    CALL_RULE       reduce using rule 24 (base -> BASE O_KEY instructions_base C_KEY .)
    LEFT            reduce using rule 24 (base -> BASE O_KEY instructions_base C_KEY .)
    RIGHT           reduce using rule 24 (base -> BASE O_KEY instructions_base C_KEY .)
    LINE            reduce using rule 24 (base -> BASE O_KEY instructions_base C_KEY .)
    JUMP            reduce using rule 24 (base -> BASE O_KEY instructions_base C_KEY .)
    NILL            reduce using rule 24 (base -> BASE O_KEY instructions_base C_KEY .)
    PUSH            reduce using rule 24 (base -> BASE O_KEY instructions_base C_KEY .)
    POP             reduce using rule 24 (base -> BASE O_KEY instructions_base C_KEY .)


state 74

    (25) instructions_base -> instruction_base instructions_base .

    C_KEY           reduce using rule 25 (instructions_base -> instruction_base instructions_base .)


state 75

    (34) loop -> ITER INT C_KEY .

    RULE            reduce using rule 34 (loop -> ITER INT C_KEY .)
    DEPTH           reduce using rule 34 (loop -> ITER INT C_KEY .)
    C_KEY           reduce using rule 34 (loop -> ITER INT C_KEY .)

